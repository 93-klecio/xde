// Generated by CoffeeScript 1.9.3
(function() {
  var __doc__, asyncArrayReturn, base, defineMemoizedPerInstanceProperty, i, j, len, len1, promisify, promisifyArray, prop, proxyAll, proxyBuilder, ref, ref1, thenify,
    slice = [].slice;

  __doc__ = "If you use this library then if you put `.promise` after a Node-style\nasynchronous function, it will turn it into a function that returns a promise\ninstead of taking a callback.\n\n```js\nrequire('instapromise');\nvar fs = require('fs');\nvar p = fs.readFile.promise('/tmp/hello', 'utf8');\np.then(console.log);\n```\n\nThe original function is available as a property on the promise-generating\nfunction (`.___instapromiseOriginalFunction___`).\n\nIf you want to promisify methods, use `.promise` after the object and before\nthe method name.\n\n```js\nrequire('instapromise');\nvar fs = require('fs');\nvar p = fs.promise.readFile('/tmp/hello', 'utf8');\np.then(console.log);\n```\n\n## Changelog\n\n### 2.0.0\nThe `Promise` polyfill is no longer provided. 1.x provided a polyfill for\nenvironments without a native `Promise` implementation, but in general, most\nenvironments you'll use now provide `Promise`.\n\n## Credits\n\nThis code is based on the proxying code used in [fibrous](https://github.com/goodeggs/fibrous/blob/master/src/fibrous.coffee).";

  thenify = require('./thenify');

  asyncArrayReturn = function(nodeStyleAsyncFunction) {
    "Transforms a Node-style async function that has multiple passed values\n(ex. (err, result, result2, result3)) into one that only has err and then\nan Array of those values (ex. (err, [result, result2, result3])) to\nconform to the (err, result) convention";
    return function() {
      var args, callback, i;
      args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
      args.push(function() {
        var cbArgs, err;
        err = arguments[0], cbArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return typeof callback === "function" ? callback(err, cbArgs) : void 0;
      });
      return nodeStyleAsyncFunction.apply(this, args);
    };
  };

  promisify = function(nodeStyleAsyncFunction) {
    "Converts a Node-style async function that takes a callback into one that\nreturns a Promise instead and doesn't need a callback";
    var f;
    f = thenify(nodeStyleAsyncFunction);
    f.___instapromiseOriginalFunction___ = nodeStyleAsyncFunction;
    return f;
  };

  promisifyArray = function(nodeStyleAsyncFunction) {
    "Converts a Node-style async function that takes a callback that it will\ncall with more than just a single `result` parameter, into a function that\nreturns a Promise that will resolve with a single value that is an Array\nthat contains all the non-`err` parameters (`result`s) that would be passed\nto the original function's callback.\n\nEx. This is useful for use with mikeal's `request` npm module, since\n`request.get` calls its callback with `(err, response, body)` and sometimes\nyou want acccess to the body.\n";
    var f;
    f = promisify(asyncArrayReturn(nodeStyleAsyncFunction));
    f.___instapromiseOriginalFunction___ = nodeStyleAsyncFunction;
    return f;
  };

  proxyAll = function(src, target, proxyFn) {
    var fn, i, key, len, ref;
    ref = Object.keys(src);
    fn = function(key) {
      if (Object.prototype[key] != null) {
        return;
      }
      if (Object.getOwnPropertyDescriptor(src, key).get != null) {
        return;
      }
      if (typeof src[key] !== 'function') {
        return;
      }
      target[key] = proxyFn(key);
      return target[key].___instapromiseOriginalFunction___ = src[key];
    };
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      fn(key);
    }
    return target;
  };

  proxyBuilder = function(prop) {
    return function(that) {
      var func, result;
      result = typeof that === 'function' ? (func = (function() {
        switch (prop) {
          case 'promise':
            return promisify(that);
          case 'promiseArray':
            return promisifyArray(that);
          default:
            throw new Error("Unknown proxy property `" + prop + "`");
        }
      })(), Object.getPrototypeOf(that) !== Function.prototype ? func.__proto__ = Object.getPrototypeOf(that)[prop] : void 0, func.___instapromiseOriginalFunction___ = that, func) : Object.create(Object.getPrototypeOf(that) && Object.getPrototypeOf(that)[prop] || Object.prototype);
      result.that = that;
      return proxyAll(that, result, function(key) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return this.that[key][prop].apply(this.that, args);
        };
      });
    };
  };

  defineMemoizedPerInstanceProperty = function(target, propertyName, factory) {
    var cacheKey;
    cacheKey = "$$___instapromise_" + propertyName + "___$$";
    return Object.defineProperty(target, propertyName, {
      enumerable: false,
      configurable: true,
      set: function(value) {
        delete this[cacheKey];
        return Object.defineProperty(this, propertyName, {
          value: value,
          writable: true,
          configurable: true,
          enumerable: true
        });
      },
      get: function() {
        if (!(Object.prototype.hasOwnProperty.call(this, cacheKey) && this[cacheKey])) {
          Object.defineProperty(this, cacheKey, {
            value: factory(this),
            writable: true,
            configurable: true,
            enumerable: false
          });
        }
        return this[cacheKey];
      }
    });
  };

  ref = [Object.prototype, Function.prototype];
  for (i = 0, len = ref.length; i < len; i++) {
    base = ref[i];
    ref1 = ['promise', 'promiseArray'];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      prop = ref1[j];
      if (base[prop] == null) {
        defineMemoizedPerInstanceProperty(base, prop, proxyBuilder(prop));
      }
    }
  }

  module.exports = {
    __doc__: __doc__,
    Promise: Promise,
    promisify: promisify,
    promisifyArray: promisifyArray
  };

}).call(this);
